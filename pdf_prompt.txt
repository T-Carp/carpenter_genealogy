Looking at your family tree document, I'll help you design an efficient relational database structure for storing genealogical relationships. Based on your requirements to trace relationships and lineages, here's my recommended approach:

## Database Schema Design

### People Table
```sql
CREATE TABLE people (
    id INTEGER PRIMARY KEY,
    given_name VARCHAR(100),
    middle_name VARCHAR(100),
    surname VARCHAR(100),
    maiden_name VARCHAR(100),  -- For tracking name changes
    birth_year INTEGER,
    death_year INTEGER1
);
```

### Relationships Table - Recommended Approach

I recommend using a **parent-child relationship model** as the primary structure, which is the most efficient for genealogical queries:

```sql
CREATE TABLE relationships (
    id INTEGER PRIMARY KEY,
    parent_id INTEGER REFERENCES people(id),
    child_id INTEGER REFERENCES people(id),
    relationship_type VARCHAR(20), -- 'biological', 'adoptive', 'step'
    UNIQUE(parent_id, child_id)
);
```

### Additional Marriage/Partnership Table
Since marriages are peer relationships (not hierarchical), store them separately:

```sql
CREATE TABLE partnerships (
    id INTEGER PRIMARY KEY,
    person1_id INTEGER REFERENCES people(id),
    person2_id INTEGER REFERENCES people(id),
    partnership_type VARCHAR(20), -- 'marriage', 'partnership'
    start_year INTEGER,
    end_year INTEGER,
    sequence_number INTEGER, -- For multiple marriages (1st, 2nd, etc.)
    CONSTRAINT check_different_people CHECK (person1_id < person2_id)
);
```

## Why This Design?

1. **Efficient Traversal**: Parent-child relationships allow efficient recursive queries to find all descendants or ancestors
2. **Simple Queries**: Finding direct relationships is straightforward
3. **Scalable**: Handles complex family structures including remarriages, step-relationships, and adoptions
4. **Normalized**: Avoids redundancy while maintaining query performance

## Sample Queries

**Find all descendants of Stephen Stone Keenum:**
```sql
WITH RECURSIVE descendants AS (
    -- Start with Stephen
    SELECT p.id, p.given_name, p.surname, 0 as generation
    FROM people p
    WHERE p.given_name = 'Stephen Stone' AND p.surname = 'Keenum'
    
    UNION ALL
    
    -- Recursively find children
    SELECT p.id, p.given_name, p.surname, d.generation + 1
    FROM people p
    JOIN relationships r ON p.id = r.child_id
    JOIN descendants d ON d.id = r.parent_id
)
SELECT * FROM descendants ORDER BY generation, surname, given_name;
```

**Find relationship between two people:**
```sql
-- This would require a more complex recursive query that traces
-- both ancestor and descendant paths to find the connection
```

## Data Entry Example
Based on your document, here's how you'd enter the first few relationships:

```sql
-- People
INSERT INTO people (id, given_name, surname, birth_year, death_year) VALUES
(1, 'Stephen Stone', 'Keenum', 1814, 1862),
(2, 'Mary', 'Smith', 1818, 1880),
(3, 'Joseph Tatum', 'Keenum', 1838, 1880),
(4, 'Parthenia', 'McIntyre', NULL, NULL);

-- Partnerships
INSERT INTO partnerships (person1_id, person2_id, partnership_type) VALUES
(1, 2, 'marriage'),  -- Stephen and Mary
(3, 4, 'marriage');  -- Joseph and Parthenia

-- Parent-Child Relationships
INSERT INTO relationships (parent_id, child_id, relationship_type) VALUES
(1, 3, 'biological'),  -- Stephen -> Joseph
(2, 3, 'biological');  -- Mary -> Joseph
```

## Alternative Consideration

If you need to store more complex relationship types (cousins, in-laws, etc.), you could add a supplementary table for derived relationships, but these can usually be computed on-the-fly from the parent-child and partnership data.

This design provides a solid foundation that can handle the complexity of family trees while maintaining good query performance for both simple lookups and complex genealogical traversals.